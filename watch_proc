#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;

if ( $^O eq 'freebsd' ) {
    require 'sys/syscall.ph';
    require 'sys/sysctl.ph';
}

# get command line args
my $verbose = 0;
my $delay   = 2;
GetOptions(
    'verbose|v' => \$verbose,
    'delay|d=i' => \$delay
) or die "Usage: $0 [-v] [-d <seconds>] <pattern>\n";
my $pattern = shift @ARGV || '.';
my $Winch   = undef;
my $Width   = `tput cols`;
my $Height  = `tput lines`;
local $SIG{WINCH} = sub { $Winch = 1 };

use constant {
    KINFO_PROC_SIZE     => 1088,    # size of kinfo_proc struct
    ARGS_OFFSET         => 8,       # offset to arguments
    PID_OFFSET          => 72,      # offset to pid in kinfo_proc
    UID_OFFSET          => 168,     # offset to uid in kinfo_proc
    COMM_OFFSET         => 447,     # offset to command name
    PARGS_LENGTH_OFFSET => 4,       # offset to length of arguments
};

# Get process list - platform specific implementation
sub get_procs {
    if ( $^O eq 'freebsd' ) {
        return get_procs_freebsd();
    }
    else {
        return get_procs_linux();
    }
}

sub get_procs_linux {
    my @procs;

    # Read /proc directory
    opendir( my $dh, '/proc' ) or die "Can't open /proc: $!";
    while ( my $pid = readdir($dh) ) {
        next unless $pid =~ /^\d+$/;

        # Read process status
        open( my $fh, '<', "/proc/$pid/status" ) or next;
        my ( $uid, $comm );
        while (<$fh>) {
            $uid  = $1 if /^Uid:\s+(\d+)/;
            $comm = $1 if /^Name:\s+(.+)/;
        }
        close $fh;
        next unless defined $uid;

        # Get username
        my @pw   = getpwuid($uid);
        my $user = @pw ? $pw[0] : 'unknown';

        # Get command line
        open( $fh, '<', "/proc/$pid/cmdline" ) or next;
        my $args = do { local $/; <$fh> };
        close $fh;

        $args ||= $comm;    # Use process name if no command line
        $args =~ s/\0/ /g;  # Replace null bytes with spaces
        $args =~ s/^[(].*?[)] //;

        push @procs,
            {
            pid  => $pid,
            args => $args,
            user => $user,
            cmd  => $comm
            };
    }
    closedir($dh);
    return \@procs;
}

sub get_procs_freebsd {
    my @procs;

    # create stable storage for MIB and size
    my @mib     = ( &CTL_KERN, &KERN_PROC, &KERN_PROC_ALL );
    my $mib_buf = pack( 'i3', @mib );
    my $size    = pack( 'i',  0 );

    # get required size
    my $ret = syscall(
        &SYS___sysctl,
        $mib_buf,        # MIB array
        scalar(@mib),    # MIB length
        undef,           # no buffer yet
        $size,           # size pointer
        undef,           # no new value
        0                # no new length
    );

    # die sprintf( 'sysctl size failed: %d %s', $!, $! ) if $ret == -1;
    return [] if $ret == -1;

    my $bufsize = unpack 'i', $size;

    # die 'Invalid size' unless $bufsize > 0;
    return [] unless $bufsize > 0;

    # allocate buffer and get data
    my $data = "\0" x $bufsize;
    $ret = syscall(
        &SYS___sysctl,
        $mib_buf,
        scalar(@mib),
        $data,    # data buffer
        $size,    # size pointer
        undef,
        0
    );

    # die sprintf( 'sysctl data failed: %d %s', $!, $! ) if $ret == -1;
    return [] if $ret == -1;

    # parse process entries
    for ( my $pos = 0; $pos < $bufsize; $pos += KINFO_PROC_SIZE ) {
        my ( $args_ptr, $pid, $uid, $comm ) = unpack(
            'x'
                . ARGS_OFFSET . 'L x'
                . ( PID_OFFSET - ARGS_OFFSET - 4 ) . 'L x'
                . ( UID_OFFSET - PID_OFFSET - 4 ) . 'L x'
                . ( COMM_OFFSET - UID_OFFSET - 4 ) . 'Z20',
            substr( $data, $pos, KINFO_PROC_SIZE )
        );

        # skip invalid entries
        next unless $pid && defined $uid && defined $comm;

        # get username
        my @pw   = getpwuid($uid);
        my $user = @pw ? $pw[0] : 'unknown';
        my $args = get_proc_args($pid);
        $args ||= $comm;    # Use process name if no command line
        $args =~ s/\0/ /g;  # Replace null bytes with spaces
        $args =~ s/^[(].*?[)] //;

        push @procs,
            {
            pid  => $pid,
            args => $args,
            user => $user,
            cmd  => $comm
            };
    }
    return \@procs;
}

# use SYS___sysctl KERN_PROC_ARGS to get process args
sub get_proc_args {
    my $pid = shift;

    # create MIB for sysctl
    my @mib     = ( &CTL_KERN, &KERN_PROC, &KERN_PROC_ARGS, $pid );
    my $mib_buf = pack( 'i4', @mib );
    my $size    = pack( 'i',  0 );

    # get required size
    my $ret = syscall(
        &SYS___sysctl,
        $mib_buf,        # MIB array
        scalar(@mib),    # MIB length
        undef,           # no buffer yet
        $size,           # size pointer
        undef,
        0
    );
    return if $ret == -1;

    my $bufsize = unpack 'i', $size;

    # die 'Invalid size' unless $bufsize > 0;
    return unless $bufsize > 0;

    # allocate buffer and get data
    my $data = "\0" x $bufsize;
    $ret = syscall(
        &SYS___sysctl,
        $mib_buf,
        scalar(@mib),
        $data,    # data buffer
        $size,    # size pointer
        undef,
        0
    );
    return if $ret == -1;

    return unpack 'Z*', $data;
}

sub print_table {
    my ( $table, $total ) = @_;
    my @max    = ( length $total, length 'total' );
    my @format = ();
    my $used   = 1;
    for my $row ( 0 .. $#{$table} ) {
        for my $col ( 0 .. $#{ $table->[$row] } ) {
            $max[$col] = length $table->[$row]->[$col]
                if ( length $table->[$row]->[$col] > ( $max[$col] || 0 ) );
        }
    }
    for my $col ( 0 .. $#max ) {
        push @format, join q(), q(%-), ( $col < $#max ) ? $max[$col] : q(),
            's';
    }
    my $format = "\e[2K" . join( q(  ), @format ) . "\n";
    print "\e[H\e[2J";
    for my $row ( @{$table} ) {
        push @{$row}, q() while $#{$row} < $#max;
        my $line = sprintf $format, @{$row};
        substr($line, $Width, length($line) - $Width) = "\n"
            if length($line) > $Width;
        print $line;
        $used++;
        last if $used >= $Height - 1;
    }
    my @final_row = ( $total, 'total' );
    push @final_row, q() while $#final_row < $#max;
    my $final_line = sprintf $format, @final_row;
    substr($final_line, $Width, length($final_line) - $Width) = "\n"
        if length($final_line) > $Width;
    print $final_line;
    $used++;

    # print empty space to fill the screen
    if ( $used < $Height ) {
        print "\e[2K\n" x ( $Height - $used );
    }
    return;
}

# loop
while (1) {

    # get process list
    my $procs = get_procs();

    # resize
    if ($Winch) {
        $Winch  = undef;
        $Width  = `tput cols`;
        $Height = `tput lines`;
    }

    # get max width of username
    my $max = 0;
    for my $proc (@$procs) {
        $max = length $proc->{user} if length $proc->{user} > $max;
    }

    # filter and count processes
    my %count = ();
    for my $proc (@$procs) {
        my $key = $verbose ? $proc->{args} : $proc->{user};
        next if $proc->{args}     =~ /watch_proc/;
        next unless $proc->{args} =~ /$pattern/;
        $key =~ s/\s+$//;
        $count{$key}++;
    }

    # print results
    my $total = 0;
    my @table = ();
    for my $key ( sort keys %count ) {
        push @table, [ $count{$key}, split q( ), $key ];
        $total += $count{$key};
    }

    print_table( \@table, $total );

    sleep $delay;
}
